#!/bin/bash

 ########################################################################
 #  MPDQ - The MPD Queuer
 #   by Steven Saus (c)2024
 #   Licensed under the MIT license
 #
 ########################################################################

# TODO - remember to change default for LOUD back to 0 


########################################################################
# Definitions
########################################################################

# This is an awful hack
if [ "$UID" == "0" ];then 
    loud "MPDQ is running as root. Note that /usr/local/share and"
    loud "/usr/local/state are being used as XDG directories."
    export XDG_CONFIG_HOME=/usr/local/share
    export XDG_STATE_HOME=/usr/local/state
fi

# Setting them here, will create if needed later
ConfigDir=${XDG_CONFIG_HOME:-$HOME/.config}/mpdq
StateDir=${XDG_STATE_HOME:-$HOME/.local/state}/mpdq
CacheDir=${XDG_CACHE_HOME:-$HOME/.local/state}/mpdq
ConfigFile=${ConfigDir}/mpdq.ini
RelayName=${StateDir}/mpdq_cmd
ConfigLogFile=${StateDir}/playedsongs.log
RunningLogRotateTime=$(TZ=UTC0 printf '%(%s)T\n' '-1')


export SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
SCRIPT=$0
grep_bin=$(which grep)

MPDBASE=""
MPD_HOST=""
MPD_PASS=""
MPD_PORT=""
# How long the playlist should be
PLAYLIST_TRIGGER=""
# How long before a song/genre gets purged from the log, IN HOURS
ROTATE_TIME=""
# How long before a particular album or artist can be played again. SEPARATE
# from the main log, and should be SHORTER. IN MINUTES  These will be checked 
# dynamically against the current logfile for thier individual time periods.
ALBUM_MINS=""
ARTIST_MINS=""
# How long a song can be to be considered for the queue, in seconds
SONGLENGTH=""
# What tool to use to get song length
MUSICINFO=""
# Where you're getting instructions from
InstructionFile=""
# Default priority for GENRE weight
DefaultPriority=1
NUMGENRES=""
# noisy feedback or not?
LOUD=1

########################################################################
# Temporary Directories
########################################################################
tmp2=$(mktemp)

ModGenre=()
ModValue=()
GenreWeight=()
ChooseGenre=()

########################################################################
# Functions
########################################################################

function loud() {
    if [ $LOUD -eq 1 ];then
        echo "$@"
    fi
}

function already_running {
    if [ -f "${StateDir}"/mpdq.pid ];then
        checkpid=$(head -n 1 "${StateDir}"/mpdq.pid)
        bob=$(ps aux | grep -e " ${checkpid} "| grep -c "mpdq")
        if [ $bob -gt 0 ];then
            loud "mpdq is already running with PID ${checkpid}." >&2
            exit 97
        else
            loud "stale mpdq.pid file found, deleting"
            rm -rf "${StateDir}"/mpdq.pid
        fi
    fi
}

function show_help {
    echo "mpdq [-c /path/to/file][-khe]"
    echo "  -c [instruction file to use]"
    echo "  -k Kill existing mpdq process "
    echo "  -e Create example instruction file "
    echo "  -h Show this help message"
    echo "  --loud get more feedback on mpdq's execution"
}

function init_config() {
    if [ ! -d "$ConfigDir" ];then
        mkdir -p "$ConfigDir"
    fi
    if [ ! -d "$StateDir" ];then
        mkdir -p "$ConfigDir"
    fi

    if [ ! -d "$CacheDir" ];then
        mkdir -p "$ConfigDir"
    fi
    if [ -f "$ConfigLogFile" ];then 
        touch "$ConfigLogFile"
    fi
}

function read_variables() {
    if [ -f "$ConfigFile" ]
    then config=$(cat "$ConfigFile")
    fi
    # If there's no config file or a line is malformed or missing, sub in the default value

    MPDBASE="$(echo "$config" | ${grep_bin} -e "^musicdir=" | cut -d = -f 2- ||
        cat "$XDG_CONFIG_HOME/mpd/mpd.conf" | ${grep_bin} "^music" | cut -d'"' -f2 ||
        echo $HOME/Music)"
    MPD_HOST="$(echo "$config" | ${grep_bin} -e "^mpdserver=" | cut -d = -f 2- || echo localhost)"
    MPD_PASS=$(echo "$config" | ${grep_bin} -e "^mpdpass=" | cut -d = -f 2-) &&
    MPD_HOST="$MPD_PASS@$MPD_HOST"
    MPD_PORT=$(echo "$config" | ${grep_bin} -e "^mpdport=" | cut -d = -f 2- || echo 6600)
    
    if [[ `echo "$config" | ${grep_bin} -c -e "^queuesize="` > 0 ]];then PLAYLIST_TRIGGER=$(echo "$config" | ${grep_bin} -e "^queuesize=" | cut -d = -f 2- );else PLAYLIST_TRIGGER="10";fi
    if [[ `echo "$config" | ${grep_bin} -c -e "^rotate_time="` > 0 ]];then ROTATE_TIME=$(echo "$config" | ${grep_bin} -e "^rotate_time=" | cut -d = -f 2- );else ROTATE_TIME="8";fi
    if [[ `echo "$config" | ${grep_bin} -c -e "^album_mins="` > 0 ]];then ALBUM_MINS=$(echo "$config" | ${grep_bin} -e "^album_mins=" | cut -d = -f 2- );else ALBUM_MINS="15";fi
    if [[ `echo "$config" | ${grep_bin} -c -e "^artist_mins="` > 0 ]];then ARTIST_MINS=$(echo "$config" | ${grep_bin} -e "^artist_mins=" | cut -d = -f 2- );else ARTIST_MINS="15";fi    
    if [[ `echo "$config" | ${grep_bin} -c -e "^songlength="` > 0 ]];then SONGLENGTH=$(echo "$config" | ${grep_bin} -e "^songlength=" | cut -d = -f 2- );else SONGLENGTH="15";fi

    
    # Determining where/how to assess song length
    if [[ `echo "$config" | ${grep_bin} -c -e "^musicinfo="` > 0 ]];then 
        MUSICINFO=$(echo "$config" | ${grep_bin} -e "^musicinfo=" | cut -d = -f 2- )
    else 
        if [ -f $(which ffprobe) ];then
            MUSICINFO=ffprobe
        else
            if [ -f $(which exiftool) ];then
                MUSICINFO=exiftool
            else
                if [ -f $(which mp3info) ];then
                    MUSICINFO=mp3info
                else
                    MUSICINFO=""
                fi
            fi
        fi
    fi
    NUMGENRES=$(mpc --host $MPD_HOST --port $MPD_PORT list genre | wc -l)

}

function rotate_songlog {
    if [ -f "$ConfigLogFile" ];then
        tempfile=$(mktemp)
        currenttime=$(TZ=UTC0 printf '%(%s)T\n' '-1')
        difftime=$(( "$SONGHOURS" * 60 * 60 ))
        hightime=$(( "$currenttime"-"$difftime" ))
        loud "Eliminating song log entries older than $SONGHOURS hours."
        #echo "$hightime / $difftime"
        cat "$ConfigLogFile" | awk -F '@@@' -v hightime="$hightime" '$1 > hightime'  > "$tempfile"
        mv -f "$tempfile" "$ConfigLogFile"
    else
        touch "$ConfigLogFile"
    fi
}

function create_example(){
    ExampleFile="$ConfigDir/example_instruction"
    loud "Default=1" > "$ExampleFile"
    mpc --host $MPD_HOST --port $MPD_PORT list genre | sed 's/$/=1/' >> "$ExampleFile"
    loud "Example config placed at $ExampleFile"
    exit
}

function killing(){
    # This is probably overkill at this point, as we are avoiding subprocesses.
    while read VPID; do
        if [ $VPID != "$$" ];then
            kill -9 "$VPID" &> /dev/null
        fi
    done < /tmp/mpdq.pid
    rm /tmp/mpdq.pid
 
    exit
}

function read_our_relay {
    # this is intentionally simple at this point, only the most recent thing in,
    # then wipe it clean, if it doesn't parse, then yeet it.
    relay_command=(tail -1 ${RelayName})
    rm -rf ${RelayName}
    case ${relay_command} in
        kill) killing ;;
        cfg=*) 
            # This is immediately tested in the next step to see if it's a file
            InstructionFile=$(echo ${relay_command} | awk -F 'cfg=' '{print $2}')
            read_instructions
            ;;
        *) ;;
    esac
}


function choose_next_song {
    # To be completely rewritten, relying on random numbers and then using 
    # the sorting criteria as a gate.  (See ROADMAP.TXT)
    
    GenreNumber=""
    OkayGenre=""
    #get random number for genre
    

    GenreNumber=$(shuf -i 1-${NUMGENRES} -n 1)
    counter=1 # this is so that if we go through ALL the genres in an hour, it'll just go ahead anyway
    counter2=0
    
    while [ -z ${OkayGenre} ] && [ ${counter} -lt ${NUMGENRES} ] 
    do
        TimesPlayed=""
        InInstruction=""
        GenreName=""
        CurrWeight=""

        GenreName=$(mpc list genre | head -n ${GenreNumber} | tail -n 1)
        # Genre name is just a straight search of the logfile, as the rotation should fix this
        TimesPlayed=(cat "${ConfigLogFile}" | grep -c -e "${GenreName}")
        InInstruction=$(${grep_bin} -c -e "${GenreName}" "${InstructionFile}")
        if [ ${InInstruction} -eq 0 ];then
            CurrWeight=${DefaultPriority}
        else
            CurrWeight=$(${grep_bin} -e "${GenreName}" "${InstructionFile}" | cut -d = -f 2-)
        fi
        if [ ${TimesPlayed} -ge ${CurrWeight} ];then
            # end loop, kick back to beginning, counter increment by one.
        else 
            #increment coutner 2

        
#CURRENT WORKPLACE


  
# POINT TWO

get number of songs in genre
randomly select # from that list
find song length
    if song length > allowed (check for hours!), goto POINT TWO, increment counter2
grep our logfile for song name, band name
    if -c > weight for either song or band, goto POINT TWO, increment counter2
add song to playlist
add info to logfile
    
    
    
    use this to find if it's been played dynamically using just one logfile

        currenttime=$(TZ=UTC0 printf '%(%s)T\n' '-1')
        difftime=$(( "$VALUE" * 60 )) #they're in minutes
        hightime=$(( "$currenttime"-"$difftime" ))
        # feed this into a variable, or grep stdin (not sure you can do that)
        cat "$GenreLogFile" | awk -F '@@@' -v hightime="$hightime" '$1 > hightime'  > "$tempfile"




        MPD_HOST="$(echo "$config" | ${grep_bin} -e "^mpdserver=" | cut -d = -f 2- || echo localhost)"
            UsedGenre=$(${grep_bin} -c -e "@@@${ChosenGenre}" ${GenreLogFile} &)
            for (( i2 = 0; i2 < ${#ModGenre[@]}; i2++ ));do
            
                if [[ "${ChosenGenre}" = "${ModGenre[$i2]}" ]];then
                    if [ "${UsedGenre}" -gt "${GenreWeight[$i2]}" ]; then
                        loud "${ChosenGenre} already used up this hour, moving on"
                        OkayGenre=""
                    else
                        OkayGenre="YES"
                    fi
                fi
            done
            counter=$((counter+1))
        done
    else
        ChosenGenre=${ChooseGenre[$RANDOM % ${#ChooseGenre[@]} ]}
    fi
    # END MODE = GENREHOUR

    nowtime=$(TZ=UTC0 printf '%(%s)T\n' '-1')
    echo "$nowtime@@@${ChosenGenre}" >> "$GenreLogFile"
    loud "Choosing song from $ChosenGenre..."
    # Changed to deal with more spaces and escaping...
    evalstring=$(printf "mpc --host %s --port %s find genre \"%s\" | shuf -n1" "${MPD_HOST}" "${MPD_PORT}" "${ChosenGenre}")
    # Again not 100% sure why the subshell needs an & here???
    SongStem=$(eval ${evalstring} &)
    SongFile="$MPDBASE/$SongStem"
    #check that it is not too long
    length=""
    # The funky formatting is so that if a full path is specified, it'll still match.
    case ${MUSICINFO} in
        *mp3info) 
            length=$(${MUSICINFO} -p "%S" "${SongFile}" 2>/dev/null)
            length=$(printf "%.0f\n" `echo "${length} / 60" | bc -l`) 
            ;;
        *exiftool)
            length=$(${MUSICINFO} "${SongFile}" 2>/dev/null | ${grep_bin} "Duration" | awk -F ':' '$2 != /.0/ {sum += 60*$2 } {sum += $3} END {print sum}' )
            ;;
        *ffprobe)
            # Why the & at the end is needed for ffprobe ONLY is beyond me...
            length=$(${MUSICINFO} "${SongFile}" 2>&1 | ${grep_bin} "Duration" | awk -F ':' '$2 != /.0/ {sum += 60*$2 } {sum += $3} END {print sum}' & )
            ;;
    esac
    if [ -z $length ];then
        loud "No song duration found. Do we have ffmpeg, exiftool, or mp3info?"
        length="0"
    fi
    if [ $length -gt $SONGLENGTH ];then
        loud "Song too long; kicking back"
        SongFileToAdd=""
    else
        #https://stackoverflow.com/questions/19801358/printing-lines-which-have-a-field-number-greater-than-in-awk
        partist=""
        case ${MUSICINFO} in
            *mp3info) 
                partist=$(${MUSICINFO} "$SongFile" 2>/dev/null |  ${grep_bin} -w -i "artist"  | awk -F ':' '{print tolower($2)}' | detox --inline)
                ;;
            *exiftool)
                partist=$(${MUSICINFO} "$SongFile" 2>/dev/null |  ${grep_bin} -w -i -E "artist\s+" | awk -F ':' '{print tolower($2)}' | detox --inline)
                ;;
            *ffprobe)
                partist=$(${MUSICINFO} "$SongFile" 2>&1 |  ${grep_bin} -w -i -E "artist\s+"  | awk -F ':' '{print tolower($2)}' | detox --inline)
                ;;
        esac

        # loud "${partist} ${MUSICINFO}"
        if [ -z "${partist}" ];then
            loud "Cannot get artist information. Do we have ffmpeg, mp3info, or exiftool?"
            partist="mpdq_unknown"
        fi


        ### This needs to be changed to handle a different file structure.
        nowtime=$(TZ=UTC0 printf '%(%s)T\n' '-1')
        partisttime=$(printf "%.0f\n" `echo "${ARTISTTIME} * 60" | bc -l`)
        threshold=$(printf "%.0f\n" `echo "${nowtime} - ${partisttime}" | bc -l`)
        matchvar=$(awk -F '@@@' -v threshold="$threshold" '$1 > threshold {print $2}' ${ConfigLogFile} | sed -e 's/[]$.*[\^]/\\&/g' | sed "s@${MPDBASE}@@g" | awk -F '//' '{print tolower($1)}' | detox --inline)
        if [[ "$matchvar" == *"$partist"* ]];then
            loud "Artist already used in time period; kicking back"
            SongFileToAdd=""
        else
                
            if cat "$ConfigLogFile" | ${grep_bin} -qF "$SongFile"; then
                loud "Song recently used; kicking back"
                SongFileToAdd=""
            else
                SongFileToAdd="$SongFile"
                #mark that we used it.
                nowtime=$(TZ=UTC0 printf '%(%s)T\n' '-1')
                echo "$nowtime@@@$SongFileToAdd" >> "$ConfigLogFile"
            fi
        fi
    fi
}



function need_next_song {
    SongFileToAdd=""

    #until it returns a valid match
    while [ -z "$SongFileToAdd" ];do
        choose_next_song
    done
    
    SongFileToAdd=${SongFileToAdd#$MPDBASE/}

    `mpc --host $MPD_HOST --port $MPD_PORT add "$SongFileToAdd"`
    #reset match tests
    SongFileToAdd=""
}

function main {
    rotate_songlog
    rotate_genrelog
    mpc --host $MPD_HOST --port $MPD_PORT --quiet consume on
    mpc --host $MPD_HOST --port $MPD_PORT --quiet random off

    
    if [ -f ${RelayName} ];then 
        read_our_relay
    fi
    # Messy, but closes all subprocesses out
    if [ ! -f /tmp/mpdq.pid ];then
        killing
    fi        
    
    playlist_length=$(mpc --host $MPD_PASS@$MPD_HOST --port $MPD_PORT playlist | wc -l)
    
    while [[ $playlist_length -lt $PLAYLIST_TRIGGER ]]; do
        need_next_song
    done

#WORKPOINT

}

########################################################################
# Wherein we parse arguments
########################################################################
init_config
read_variables


while [ $# -gt 0 ]; do
option="$1"
    case $option in
        --loud) 
            export LOUD=1
            shift
            ;;             
        -e) create_example
            exit
            ;;
        -c) already_running  # should abort if already running
            shift
            InstructionFile="$1"
            shift
            ;;
        -h)
            show_help
            exit
            ;;
        -r) 
            shift
            echo "$1" > ${RelayName}
            loud "${1} sent to mpdq relay file"
            exit
            ;;
        -k)
            already_running
            echo "kill" > ${RelayName}
            loud "Kill command sent to relay."
            # TODO - sleep here, wait to see if pidfile needs reaping
            ;;            
            
    esac    
done

# Normal operation, so check for already running, then write our PID
already_running
echo "$$" >> /tmp/mpdq.pid

# rotation now included in loop. 
# read_instructions -- do we need to anymore? NOPE.
# determine_genre_weights -- don't need either

main
