#!/bin/bash

 ########################################################################
 #  MPDQ - The MPD Queuer
 #   by Steven Saus (c)2024
 #   Licensed under the MIT license
 #
 ########################################################################

# TODO - remember to change default for LOUD back to 0 


########################################################################
# Definitions
########################################################################

# This is an awful hack
if [ "$UID" == "0" ];then 
    loud "MPDQ is running as root. Note that /usr/local/share and"
    loud "/usr/local/state are being used as XDG directories."
    export XDG_CONFIG_HOME=/usr/local/share
    export XDG_STATE_HOME=/usr/local/state
fi

# Setting them here, will create if needed later
ConfigDir=${XDG_CONFIG_HOME:-$HOME/.config}/mpdq
StateDir=${XDG_STATE_HOME:-$HOME/.local/state}/mpdq
CacheDir=${XDG_CACHE_HOME:-$HOME/.local/state}/mpdq
ConfigFile=${ConfigDir}/mpdq.ini
RelayName=${StateDir}/mpdq_cmd
ConfigLogFile=${StateDir}/playedsongs.log
RunningLogRotateTime=$(TZ=UTC0 printf '%(%s)T\n' '-1')


export SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
SCRIPT=$0
grep_bin=$(which grep)

MPDBASE=""
MPD_HOST=""
MPD_PASS=""
MPD_PORT=""
# How long the playlist should be
PLAYLIST_TRIGGER=""
# How long before a song/genre gets purged from the log, IN HOURS
ROTATE_TIME=""
# How long before a particular album or artist can be played again. SEPARATE
# from the main log, and should be SHORTER. IN MINUTES  These will be checked 
# dynamically against the current logfile for thier individual time periods.
ALBUM_MINS=""
ARTIST_MINS=""
# How long a song can be to be considered for the queue, in seconds
SONGLENGTH=""
# What tool to use to get song length
MUSICINFO=""
# Where you're getting instructions from
InstructionFile=""
# Default priority for GENRE weight
DefaultPriority=1
NUMGENRES=""
# noisy feedback or not?
LOUD=1

########################################################################
# Temporary Directories
########################################################################
tmp2=$(mktemp)

ModGenre=()
ModValue=()
GenreWeight=()
ChooseGenre=()

########################################################################
# Functions
########################################################################

function loud() {
    if [ $LOUD -eq 1 ];then
        echo "$@"
    fi
}

function already_running {
    if [ -f "${StateDir}"/mpdq.pid ];then
        checkpid=$(head -n 1 "${StateDir}"/mpdq.pid)
        bob=$(ps aux | grep -e " ${checkpid} "| grep -c "mpdq")
        if [ $bob -gt 0 ];then
            loud "mpdq is already running with PID ${checkpid}." >&2
            exit 97
        else
            loud "stale mpdq.pid file found, deleting"
            rm -rf "${StateDir}"/mpdq.pid
        fi
    fi
}

function show_help {
    echo "mpdq [-c /path/to/file][-khe]"
    echo "  -c [instruction file to use]"
    echo "  -k Kill existing mpdq process "
    echo "  -e Create example instruction file "
    echo "  -h Show this help message"
    echo "  --loud get more feedback on mpdq's execution"
}

function init_config() {
    if [ -f "$GenreLogFile" ]
    then touch "$GenreLogFile"
    fi
    if [ -f "$ConfigLogFile" ]
    then touch "$ConfigLogFile"
    fi
}

function read_variables() {
    if [ -f "$ConfigFile" ]
    then config=$(cat "$ConfigFile")
    fi
    # If there's no config file or a line is malformed or missing, sub in the default value

    MPDBASE="$(echo "$config" | ${grep_bin} -e "^musicdir=" | cut -d = -f 2- ||
        cat "$XDG_CONFIG_HOME/mpd/mpd.conf" | ${grep_bin} "^music" | cut -d'"' -f2 ||
        echo $HOME/Music)"
    MPD_HOST="$(echo "$config" | ${grep_bin} -e "^mpdserver=" | cut -d = -f 2- || echo localhost)"
    MPD_PASS=$(echo "$config" | ${grep_bin} -e "^mpdpass=" | cut -d = -f 2-) &&
    MPD_HOST="$MPD_PASS@$MPD_HOST"
    MPD_PORT=$(echo "$config" | ${grep_bin} -e "^mpdport=" | cut -d = -f 2- || echo 6600)
    
    if [[ `echo "$config" | ${grep_bin} -c -e "^queuesize="` > 0 ]];then PLAYLIST_TRIGGER=$(echo "$config" | ${grep_bin} -e "^queuesize=" | cut -d = -f 2- );else PLAYLIST_TRIGGER="10";fi
    if [[ `echo "$config" | ${grep_bin} -c -e "^rotate_time="` > 0 ]];then ROTATE_TIME=$(echo "$config" | ${grep_bin} -e "^rotate_time=" | cut -d = -f 2- );else ROTATE_TIME="8";fi
    if [[ `echo "$config" | ${grep_bin} -c -e "^album_mins="` > 0 ]];then ALBUM_MINS=$(echo "$config" | ${grep_bin} -e "^album_mins=" | cut -d = -f 2- );else ALBUM_MINS="15";fi
    if [[ `echo "$config" | ${grep_bin} -c -e "^artist_mins="` > 0 ]];then ARTIST_MINS=$(echo "$config" | ${grep_bin} -e "^artist_mins=" | cut -d = -f 2- );else ARTIST_MINS="15";fi    
    if [[ `echo "$config" | ${grep_bin} -c -e "^songlength="` > 0 ]];then SONGLENGTH=$(echo "$config" | ${grep_bin} -e "^songlength=" | cut -d = -f 2- );else SONGLENGTH="15";fi

    
    # Determining where/how to assess song length
    if [[ `echo "$config" | ${grep_bin} -c -e "^musicinfo="` > 0 ]];then 
        MUSICINFO=$(echo "$config" | ${grep_bin} -e "^musicinfo=" | cut -d = -f 2- )
    else 
        if [ -f $(which ffprobe) ];then
            MUSICINFO=ffprobe
        else
            if [ -f $(which exiftool) ];then
                MUSICINFO=exiftool
            else
                if [ -f $(which mp3info) ];then
                    MUSICINFO=mp3info
                else
                    MUSICINFO=""
                fi
            fi
        fi
    fi
    NUMGENRES=$(mpc --host $MPD_HOST --port $MPD_PORT list genre | wc -l)

}

function rotate_songlog {
    if [ -f "$ConfigLogFile" ];then
        tempfile=$(mktemp)
        currenttime=$(TZ=UTC0 printf '%(%s)T\n' '-1')
        difftime=$(( "$SONGHOURS" * 60 * 60 ))
        hightime=$(( "$currenttime"-"$difftime" ))
        loud "Eliminating song log entries older than $SONGHOURS hours."
        #echo "$hightime / $difftime"
        cat "$ConfigLogFile" | awk -F '@@@' -v hightime="$hightime" '$1 > hightime'  > "$tempfile"
        mv -f "$tempfile" "$ConfigLogFile"
    else
        touch "$ConfigLogFile"
    fi
}


function killing(){
    # This is probably overkill at this point, as we are avoiding subprocesses.
    while read VPID; do
        if [ $VPID != "$$" ];then
            kill -9 "$VPID" &> /dev/null
        fi
    done < /tmp/mpdq.pid
    rm /tmp/mpdq.pid
 
    exit
}

function read_our_relay {
    # this is intentionally simple at this point, only the most recent thing in,
    # then wipe it clean, if it doesn't parse, then yeet it.
    relay_command=(tail -1 ${RelayName})
    rm -rf ${RelayName}
    case ${relay_command} in
        kill) killing ;;
        cfg=*) 
            # This is immediately tested in the next step to see if it's a file
            InstructionFile=$(echo ${relay_command} | awk -F 'cfg=' '{print $2}')
            read_instructions
            ;;
        *) ;;
    esac
}


function main {
    rotate_songlog
    rotate_genrelog
    mpc --host $MPD_HOST --port $MPD_PORT --quiet consume on
    mpc --host $MPD_HOST --port $MPD_PORT --quiet random off

    
    if [ -f ${RelayName} ];then 
        read_our_relay
    fi
    # Messy, but closes all subprocesses out
    if [ ! -f /tmp/mpdq.pid ];then
        killing
    fi        
    
    #CURRENT WORKPOINT
}

########################################################################
# Wherein we parse arguments
########################################################################
init_config
read_variables


while [ $# -gt 0 ]; do
option="$1"
    case $option in
        --loud) 
            export LOUD=1
            shift
            ;;             
        -e) create_example
            exit
            ;;
        -c) already_running  # should abort if already running
            shift
            InstructionFile="$1"
            shift
            ;;
        -h)
            show_help
            exit
            ;;
        -r) 
            shift
            echo "$1" > ${RelayName}
            loud "${1} sent to mpdq relay file"
            exit
            ;;
        -k)
            already_running
            echo "kill" > ${RelayName}
            loud "Kill command sent to relay."
            # TODO - sleep here, wait to see if pidfile needs reaping
            ;;            
            
    esac    
done

# Normal operation, so check for already running, then write our PID
already_running
echo "$$" >> /tmp/mpdq.pid

# rotation now included in loop. 
# read_instructions -- do we need to anymore? NOPE.
# determine_genre_weights -- don't need either

main
